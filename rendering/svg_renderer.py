"""
SVG renderer for perspective grids.

This module creates scalable vector graphics output of the generated grids.
"""

import xml.etree.ElementTree as ET
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from pathlib import Path

from perspective.grid_generator import GridLine


@dataclass
class SVGStyle:
    """Style configuration for SVG elements."""
    stroke_color: str = "#333333"
    stroke_width: float = 1.0
    stroke_opacity: float = 0.8
    fill: str = "none"


@dataclass
class SVGConfig:
    """Configuration for SVG rendering."""
    width: int = 1920
    height: int = 1080
    background_color: str = "#ffffff"
    grid_style: SVGStyle = None
    boundary_style: SVGStyle = None
    show_labels: bool = True
    label_font_size: int = 14
    label_font_family: str = "Arial, sans-serif"
    
    def __post_init__(self):
        """Set default styles if not provided."""
        if self.grid_style is None:
            self.grid_style = SVGStyle()
        if self.boundary_style is None:
            self.boundary_style = SVGStyle(
                stroke_color="#000000",
                stroke_width=2.0,
                stroke_opacity=1.0
            )


class SVGRenderer:
    """Renders perspective grids as SVG files."""
    
    def __init__(self, config: SVGConfig = None):
        """
        Initialize SVG renderer.
        
        Args:
            config: SVG rendering configuration
        """
        self.config = config or SVGConfig()
    
    def render(self, grid_lines: List[GridLine], output_path: str,
               title: str = "Perspective Grid") -> bool:
        """
        Render grid lines to SVG file.
        
        Args:
            grid_lines: List of grid lines to render
            output_path: Path to save SVG file
            title: Title for the SVG document
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Create SVG root element
            svg_root = self._create_svg_root(title)
            
            # Add background
            self._add_background(svg_root)
            
            # Group lines by type for organized output
            grouped_lines = self._group_lines_by_type(grid_lines)
            
            # Add grid lines
            self._add_grid_lines(svg_root, grouped_lines)
            
            # Add panel labels if requested
            if self.config.show_labels:
                self._add_panel_labels(svg_root, grid_lines)
            
            # Write to file
            self._write_svg_file(svg_root, output_path)
            
            return True
            
        except Exception as e:
            print(f"Error rendering SVG: {e}")
            return False
    
    def _create_svg_root(self, title: str) -> ET.Element:
        """Create the root SVG element with proper attributes."""
        svg = ET.Element("svg")
        svg.set("xmlns", "http://www.w3.org/2000/svg")
        svg.set("width", str(self.config.width))
        svg.set("height", str(self.config.height))
        svg.set("viewBox", f"0 0 {self.config.width} {self.config.height}")
        
        # Add title
        title_elem = ET.SubElement(svg, "title")
        title_elem.text = title
        
        # Add metadata
        desc = ET.SubElement(svg, "desc")
        desc.text = "Perspective grid generated by Forced Aspect Grid Tool"
        
        return svg
    
    def _add_background(self, svg_root: ET.Element):
        """Add background rectangle."""
        bg = ET.SubElement(svg_root, "rect")
        bg.set("x", "0")
        bg.set("y", "0")
        bg.set("width", str(self.config.width))
        bg.set("height", str(self.config.height))
        bg.set("fill", self.config.background_color)
    
    def _group_lines_by_type(self, grid_lines: List[GridLine]) -> Dict[str, List[GridLine]]:
        """Group grid lines by type for organized rendering."""
        groups = {
            "boundary": [],
            "horizontal": [],
            "vertical": []
        }
        
        for line in grid_lines:
            line_type = line.line_type
            if line_type in groups:
                groups[line_type].append(line)
        
        return groups
    
    def _add_grid_lines(self, svg_root: ET.Element, grouped_lines: Dict[str, List[GridLine]]):
        """Add all grid lines to SVG, grouped by type."""
        
        # Add boundary lines (panel edges)
        if grouped_lines["boundary"]:
            boundary_group = ET.SubElement(svg_root, "g")
            boundary_group.set("id", "panel-boundaries")
            boundary_group.set("class", "boundaries")
            
            for line in grouped_lines["boundary"]:
                self._add_line(boundary_group, line, self.config.boundary_style)
        
        # Add interior grid lines
        interior_group = ET.SubElement(svg_root, "g")
        interior_group.set("id", "grid-lines")
        interior_group.set("class", "grid")
        
        # Horizontal lines
        if grouped_lines["horizontal"]:
            h_group = ET.SubElement(interior_group, "g")
            h_group.set("class", "horizontal-lines")
            
            for line in grouped_lines["horizontal"]:
                self._add_line(h_group, line, self.config.grid_style)
        
        # Vertical lines
        if grouped_lines["vertical"]:
            v_group = ET.SubElement(interior_group, "g")
            v_group.set("class", "vertical-lines")
            
            for line in grouped_lines["vertical"]:
                self._add_line(v_group, line, self.config.grid_style)
    
    def _add_line(self, parent: ET.Element, line: GridLine, style: SVGStyle):
        """Add a single line element to the SVG."""
        line_elem = ET.SubElement(parent, "line")
        line_elem.set("x1", f"{line.start.x:.2f}")
        line_elem.set("y1", f"{line.start.y:.2f}")
        line_elem.set("x2", f"{line.end.x:.2f}")
        line_elem.set("y2", f"{line.end.y:.2f}")
        line_elem.set("stroke", style.stroke_color)
        line_elem.set("stroke-width", str(style.stroke_width))
        line_elem.set("stroke-opacity", str(style.stroke_opacity))
        line_elem.set("fill", style.fill)
        
        # Add data attributes for panel identification
        line_elem.set("data-panel", line.panel_label)
        line_elem.set("data-type", line.line_type)
    
    def _add_panel_labels(self, svg_root: ET.Element, grid_lines: List[GridLine]):
        """Add text labels for each panel."""
        labels_group = ET.SubElement(svg_root, "g")
        labels_group.set("id", "panel-labels")
        labels_group.set("class", "labels")
        
        # Find label positions for each panel
        panel_positions = self._calculate_label_positions(grid_lines)
        
        for panel_label, position in panel_positions.items():
            if position:
                text_elem = ET.SubElement(labels_group, "text")
                text_elem.set("x", f"{position['x']:.2f}")
                text_elem.set("y", f"{position['y']:.2f}")
                text_elem.set("font-family", self.config.label_font_family)
                text_elem.set("font-size", str(self.config.label_font_size))
                text_elem.set("text-anchor", "middle")
                text_elem.set("dominant-baseline", "central")
                text_elem.set("fill", "#000000")
                text_elem.set("stroke", "#ffffff")
                text_elem.set("stroke-width", "2")
                text_elem.set("paint-order", "stroke fill")
                text_elem.text = panel_label
    
    def _calculate_label_positions(self, grid_lines: List[GridLine]) -> Dict[str, Optional[Dict[str, float]]]:
        """Calculate optimal positions for panel labels."""
        panel_bounds = {}
        
        # Calculate bounds for each panel
        for line in grid_lines:
            panel_label = line.panel_label
            
            if panel_label not in panel_bounds:
                panel_bounds[panel_label] = {
                    "min_x": float("inf"), "max_x": float("-inf"),
                    "min_y": float("inf"), "max_y": float("-inf")
                }
            
            bounds = panel_bounds[panel_label]
            
            # Update bounds with line endpoints
            for point in [line.start, line.end]:
                bounds["min_x"] = min(bounds["min_x"], point.x)
                bounds["max_x"] = max(bounds["max_x"], point.x)
                bounds["min_y"] = min(bounds["min_y"], point.y)
                bounds["max_y"] = max(bounds["max_y"], point.y)
        
        # Calculate center positions
        label_positions = {}
        for panel_label, bounds in panel_bounds.items():
            if (bounds["min_x"] != float("inf") and 
                bounds["max_x"] != float("-inf")):
                
                center_x = (bounds["min_x"] + bounds["max_x"]) / 2
                center_y = (bounds["min_y"] + bounds["max_y"]) / 2
                
                # Ensure labels are within canvas bounds
                center_x = max(20, min(center_x, self.config.width - 20))
                center_y = max(20, min(center_y, self.config.height - 20))
                
                label_positions[panel_label] = {"x": center_x, "y": center_y}
            else:
                label_positions[panel_label] = None
        
        return label_positions
    
    def _write_svg_file(self, svg_root: ET.Element, output_path: str):
        """Write SVG tree to file with proper formatting."""
        # Create output directory if it doesn't exist
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Create tree and write with declaration
        tree = ET.ElementTree(svg_root)
        
        # Format the XML nicely
        self._indent_xml(svg_root)
        
        # Write to file
        with open(output_path, 'wb') as f:
            f.write(b'<?xml version="1.0" encoding="UTF-8"?>\n')
            tree.write(f, encoding='utf-8')
    
    def _indent_xml(self, elem: ET.Element, level: int = 0):
        """Add indentation to XML for better readability."""
        indent = "\n" + level * "  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = indent + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = indent
            for child in elem:
                self._indent_xml(child, level + 1)
            if not child.tail or not child.tail.strip():
                child.tail = indent
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = indent
    
    def get_file_size_estimate(self, grid_lines: List[GridLine]) -> int:
        """
        Estimate the file size of the SVG output.
        
        Args:
            grid_lines: List of grid lines to estimate for
            
        Returns:
            Estimated file size in bytes
        """
        # Base SVG overhead
        base_size = 1000  # XML declaration, SVG element, etc.
        
        # Estimate bytes per line (including attributes)
        bytes_per_line = 120
        
        # Estimate bytes per label
        bytes_per_label = 150
        
        total_size = base_size + (len(grid_lines) * bytes_per_line)
        
        if self.config.show_labels:
            # Count unique panels
            unique_panels = len(set(line.panel_label for line in grid_lines))
            total_size += unique_panels * bytes_per_label
        
        return total_size


def create_standard_svg_config(width: int = 1920, height: int = 1080) -> SVGConfig:
    """
    Create a standard SVG configuration.
    
    Args:
        width: Canvas width in pixels
        height: Canvas height in pixels
        
    Returns:
        SVGConfig with standard settings
    """
    return SVGConfig(
        width=width,
        height=height,
        background_color="#ffffff",
        grid_style=SVGStyle(
            stroke_color="#666666",
            stroke_width=1.0,
            stroke_opacity=0.6
        ),
        boundary_style=SVGStyle(
            stroke_color="#000000",
            stroke_width=2.5,
            stroke_opacity=1.0
        ),
        show_labels=True,
        label_font_size=16
    )
